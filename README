# N-Puzzle A* Search Algorithm

A comprehensive implementation of the classic sliding tile puzzle solver using the A* search algorithm with multiple heuristic functions.

## About

The N-Puzzle is a sliding puzzle consisting of a grid of numbered tiles with one empty space. The goal is to arrange the tiles in numerical order by sliding them into the empty space. This implementation provides optimal solutions using the A* search algorithm.

## Features

- A* search algorithm with guaranteed optimal solutions
- Two heuristic functions: Tiles Out of Place and Manhattan Distance
- Interactive menu-driven interface
- Step-by-step solution visualization
- Search tree analysis and statistics
- Modular code architecture

## Project Structure

```
npuzzle/
├── npuzzle.h          # Core definitions and data structures
├── main.c             # Program entry point and user interface
├── npuzzle_core.c     # Puzzle state management and operations
├── heuristic.c        # Heuristic function implementations
├── astar.c            # A* search algorithm implementation
├── display.c          # Visualization and output formatting
└── Makefile           # Build system configuration
```

## Building and Running

```bash
make
./npuzzle
```

## Usage

The program presents an interactive menu with four options:

1. **Default Puzzle** - Standard 3x3 configuration
2. **Challenging Puzzle** - Complex test case
3. **Custom Puzzle** - User-defined initial state
4. **Exit** - Quit the program

After selecting a puzzle, choose between two heuristic functions:
- Tiles Out of Place
- Manhattan Distance

## Algorithm Details

The A* algorithm uses the evaluation function f(n) = g(n) + h(n), where:
- g(n): Cost from start to current node
- h(n): Heuristic estimate to goal
- f(n): Total estimated cost

### Heuristic Functions

**Tiles Out of Place**: Counts the number of tiles not in their target positions.

**Manhattan Distance**: Calculates the sum of distances each tile must move to reach its goal position.

## Output

The program provides:
- Complete solution path with step-by-step moves
- Search tree visualization
- Performance statistics including nodes explored, solution depth, and branching factor

## Technical Implementation

- TreeNode structure containing puzzle state, costs, and node relationships
- Efficient open and closed list management
- Goal state detection and duplicate checking
- Memory-efficient tree traversal
- Admissible heuristics ensuring optimal solutions

## Educational Purpose

This project demonstrates artificial intelligence search algorithms, data structures, algorithm analysis, and software engineering principles for the CE368 course.
